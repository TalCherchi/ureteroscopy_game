<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>סימולטור ריסוק אבנים</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
            font-family: 'Rubik', sans-serif;
            color: white;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: #0f131a;
            border-radius: 8px;
            cursor: default; /* Default cursor */
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* Header Styles */
        .header {
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 20px;
            align-self: center;
            backdrop-filter: blur(4px);
            max-width: 90%;
            border: 1px solid #4a5568;
            transition: all 0.5s ease;
            position: relative;
        }

        .header.top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            right: auto;
            align-self: flex-start;
            text-align: right;
            max-width: 300px;
            transform: none;
            margin: 0;
        }

        h1 { margin: 0; font-size: 1.3rem; color: #63b3ed; margin-bottom: 8px; }
        p { margin: 5px 0 0; font-size: 1rem; color: #e2e8f0; line-height: 1.5; }
        .subtext { font-size: 0.85rem; color: #a0aec0; margin-top: 10px; display: block; }
        
        ul { text-align: right; padding-right: 20px; margin: 10px 0; font-size: 0.95rem; color: #cbd5e0; }
        li { margin-bottom: 5px; }

        /* Buttons */
        .btn-action {
            pointer-events: auto;
            background: #3182ce;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 15px;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .btn-action:active { transform: scale(0.95); }
        .btn-action.secondary {
            background: transparent;
            border: 2px solid #4a5568;
            padding: 8px 20px;
            font-size: 0.9rem;
            color: #cbd5e0;
            margin-top: 10px;
            background-color: rgba(0,0,0,0.3); 
        }

        /* Laser Button */
        #laser-btn {
            pointer-events: auto;
            position: absolute;
            bottom: 90px; /* Above the back button */
            right: 20px;  /* Aligned to the right */
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, #fc8181 0%, #c53030 100%);
            border: 4px solid #fff;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 0 15px #c53030;
            transition: transform 0.1s, opacity 0.3s;
            opacity: 0; 
            transform: scale(0);
            margin-bottom: 0; /* Removed margin as we use absolute positioning */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #laser-btn.visible {
            opacity: 1;
            transform: scale(1);
        }

        #laser-btn.active {
            box-shadow: 0 0 25px #f56565, 0 0 50px #f56565 inset;
            animation: pulse 1s infinite;
        }
        
        #laser-btn.basket-mode {
            background: radial-gradient(circle, #63b3ed 0%, #3182ce 100%);
            box-shadow: 0 0 15px #3182ce;
            font-size: 1.1rem;
        }
        #laser-btn.basket-mode.active {
            box-shadow: 0 0 25px #63b3ed, 0 0 50px #63b3ed inset;
        }

        /* Modal / Instructions */
        #modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        .modal-content {
            background: white;
            color: #2d3748;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        .modal-content h2 { margin-top: 0; color: #2b6cb0; font-size: 1.5rem; }
        .modal-content p { color: #4a5568; margin-bottom: 15px; }
        
        .info-list { text-align: right; background: #f7fafc; padding: 15px; border-radius: 8px; margin: 10px 0; }
        .info-list h3 { font-size: 1rem; color: #2d3748; margin: 0 0 5px 0; }
        .info-list ul { padding-right: 20px; margin: 0; color: #4a5568; }

        .hidden { display: none !important; }

        .bottom-nav {
            position: absolute;
            bottom: 20px;
            right: 20px; 
            left: auto;
            width: auto;
            display: flex;
            pointer-events: none;
        }
        .bottom-nav button {
            pointer-events: auto;
        }

        .anatomy-label {
            position: absolute;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="labels-container"></div>

    <div class="ui-layer">
        <!-- Main Info Box -->
        <div class="header hidden" id="game-instruction-box">
            <h1 id="stage-title">כותרת</h1>
            <div id="stage-content">תוכן</div>
            <button id="next-stage-btn" class="btn-action hidden" onclick="nextStage()">המשך</button>
        </div>

        <!-- Laser Button -->
        <div id="laser-btn">לייזר</div>

        <!-- Back Button -->
        <div class="bottom-nav">
            <button id="back-btn" class="btn-action secondary hidden" onclick="goBack()">חזור</button>
        </div>
    </div>

    <!-- Modals -->
    <div id="modal">
        <div class="modal-content" id="start-screen">
            <h2>ברוכים הבאים לסימולציה</h2>
            <p>בסימולציה הזו נלמד בצורה רגועה וברורה מה קורה במהלך ניתוח אורטרוסקופיה – הליך קצר שנועד לאתר או להסיר אבנים מדרכי השתן.</p>
            <p>מטרת סימולציה זו היא להגביר את הבנת הפרוצדורה הרפואית שאתם עומדים לעבור באמצעות השתתפות פעילה.</p>
            <span class="subtext">הסימולציה אורכת כ-5 דקות • בכל שלב תוכלו לעצור ולחזור</span>
            <button class="btn-action" onclick="startGameFlow()">בואו נתחיל</button>
        </div>
        
        <div class="modal-content hidden" id="success-screen">
            <h2 style="color: #38a169;">הניתוח עבר בהצלחה!</h2>
            
            <div class="info-list">
                <h3>אחרי הניתוח – מה מרגישים?</h3>
                <ul>
                    <li>מיד לאחר ההליך תישארו למעקב קצר. לרוב חוזרים הביתה באותו יום.</li>
                    <li>ביום-יומיים הראשונים ייתכן צריבה קלה או צורך דחוף להשתין. זה טבעי וחולף.</li>
                    <li>חשוב לפעול לפי הוראות הרופא וליטול תרופות במידת הצורך.</li>
                </ul>
            </div>

            <div class="info-list" style="background: #e6fffa;">
                <h3>תופעות נפוצות (טבעיות):</h3>
                <ul>
                    <li>צריבה קלה בשתן</li>
                    <li>צורך תכוף להשתין</li>
                    <li>דם קל בשתן (ביומיים הראשונים)</li>
                    <li>תחושת אי נוחות קלה</li>
                </ul>
                <p style="margin-top:5px; font-weight:bold; color: #2c7a7b;">✓ כל התופעות הללו חולפות תוך מספר ימים</p>
            </div>
            <button class="btn-action" onclick="resetGame()">התחל מחדש</button>
        </div>
    </div>
</div>

<script>
    // --- Configuration & State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const laserBtn = document.getElementById('laser-btn');
    const modal = document.getElementById('modal');
    const startScreen = document.getElementById('start-screen');
    const successScreen = document.getElementById('success-screen');
    const labelsContainer = document.getElementById('labels-container');
    const instructionBox = document.getElementById('game-instruction-box');
    const stageTitle = document.getElementById('stage-title');
    const stageContent = document.getElementById('stage-content');
    const nextStageBtn = document.getElementById('next-stage-btn');
    const backBtn = document.getElementById('back-btn');
    
    const STAGES = [
        'intro', 
        'device_intro',
        'demo_handle', 'demo_tract', 
        'laser_explainer', 
        'navigate_handle', 'navigate_tract', 
        'destroy', 
        'post_op'
    ];
    let currentStageIndex = 0;
    
    let isLaserActive = false;
    let autoLaserTimer = 0;
    
    let width, height;
    
    // Entities
    let fullPath = []; 
    let organStartIndex = 0;
    let scopeChain = []; 
    let stones = []; 
    let particles = [];
    
    // Camera
    let cameraZoom = 1;
    let cameraOffset = { x: 0, y: 0 };
    let targetZoom = 1;
    let targetOffset = { x: 0, y: 0 };

    // Interaction
    const mouse = { x: 0, y: 0, isDown: false };
    let scopeProgressIndex = 0; 
    let isGrabbingTip = false; 
    
    // Constants
    const KIDNEY_COLOR = '#FEB2B2';
    const KIDNEY_STROKE = '#E53E3E';
    const TRACT_COLOR = '#FED7D7';
    const TRACT_STROKE = '#F56565';
    const STONE_COLOR = '#D69E2E';
    const TRACT_RADIUS = 14; 

    let levelCompleteTime = null; 
    let breathOffset = 0; 
    let visibilityObscurity = 0; 

    function startGameFlow() {
        modal.classList.add('hidden');
        startScreen.classList.add('hidden');
        successScreen.classList.add('hidden');
        
        handleResize(); // Generates path
        initStones();
        
        goToStage(1); 
        requestAnimationFrame(loop);
    }

    function goToStage(index) {
        if (index < 0) index = 0;
        if (index >= STAGES.length) index = STAGES.length - 1;
        
        currentStageIndex = index;
        const stage = STAGES[index];

        // UI Reset
        instructionBox.classList.remove('hidden');
        instructionBox.classList.remove('top-left'); 
        nextStageBtn.classList.add('hidden');
        laserBtn.classList.remove('visible');
        laserBtn.innerText = "לייזר";
        backBtn.classList.remove('hidden');
        
        // View Reset
        targetZoom = 1;
        targetOffset = {x: 0, y:0};
        autoLaserTimer = 0;
        isLaserActive = false;
        isGrabbingTip = false;
        levelCompleteTime = null; 
        breathOffset = 0; 
        visibilityObscurity = 0; 

        // Stage Logic
        if (stage === 'intro') {
            modal.classList.remove('hidden');
            startScreen.classList.remove('hidden');
            backBtn.classList.add('hidden');
            instructionBox.classList.add('hidden');
        }
        else if (stage === 'device_intro') {
            instructionBox.classList.add('top-left');
            
            stageTitle.innerText = "הכרת המכשיר: אורטרוסקופ";
            stageContent.innerHTML = `
                <div style="text-align:right;">
                <p>זהו המכשיר שבו ישתמש הרופא:</p>
                <ul style="list-style-type: disc; margin-right: 20px;">
                    <li><b>ידית אחיזה:</b> לשליטה מלאה של הרופא.</li>
                    <li><b>סיב גמיש:</b> נכנס בעדינות לדרכי השתן.</li>
                    <li><b>מצלמה ולייזר:</b> בקצה הסיב נמצאים אמצעי הראייה והטיפול.</li>
                </ul>
                </div>
            `;
            nextStageBtn.classList.remove('hidden');
        }
        else if (stage === 'demo_handle') {
            instructionBox.classList.add('top-left');
            stageTitle.innerText = "שלב 1: החדרת המכשיר";
            stageContent.innerHTML = `
                <p>הבדיקה מתחילה בהחדרת צינורית דקה וגמישה דרך פתח השופכה.</p>
                <div style="margin-top:10px; font-weight:bold; color: #90cdf4;">✓ ללא חתכים בגוף</div>
            `;
            scopeProgressIndex = 0;
            initScopeAt(0);
            nextStageBtn.classList.add('hidden');
        }
        else if (stage === 'demo_tract') {
            instructionBox.classList.add('top-left');
            stageTitle.innerText = "שלב 2: תנועה בדרכי השתן";
            stageContent.innerHTML = `
                <p>הצינורית מתקדמת בעדינות במעלה השופכן עד להגעה לכליה.</p>
            `;
            targetZoom = 1.3;
            targetOffset = {
                x: (width/2) * (1 - targetZoom), 
                y: (height * 0.4) * (1 - targetZoom) 
            };
            scopeProgressIndex = organStartIndex;
            initScopeAt(organStartIndex);
            nextStageBtn.classList.add('hidden'); 
        }
        else if (stage === 'laser_explainer') {
            stageTitle.innerText = "ריסוק האבן";
            stageContent.innerHTML = `
                <p>כאשר הרופא מזהה את האבן הוא משתמש בקרן לייזר מדויקת כדי לפרק אותה.</p>
            `;
            targetZoom = 2.0;
            if (fullPath.length > 0) {
                const endP = fullPath[fullPath.length-1];
                targetOffset = {
                    x: (width / 2) - (endP.x * 2.0),
                    y: (height / 2) - (endP.y * 2.0)
                };
            }
            nextStageBtn.classList.remove('hidden');
        }
        else if (stage === 'navigate_handle') {
            instructionBox.classList.add('top-left');
            stageTitle.innerText = "תורכם: החדרת הצינורית";
            stageContent.innerHTML = "תפסו את <b>קצה הצינורית</b> וגררו אותו אל תוך פתח השופכה.";
            scopeProgressIndex = 0;
            initScopeAt(0);
        }
        else if (stage === 'navigate_tract') {
            instructionBox.classList.add('top-left');
            stageTitle.innerText = "תורכם: ניווט לכליה";
            stageContent.innerHTML = "המשיכו לגרור את <b>קצה הצינורית</b> במעלה המסלול עד שתגיעו לאבן.";
            
            targetZoom = 1.1; 
            targetOffset = {
                x: (width/2) * (1 - targetZoom), 
                y: (height * 0.55) * (1 - targetZoom)
            };
            scopeProgressIndex = organStartIndex + 5;
            initScopeAt(scopeProgressIndex);
        }
        else if (stage === 'destroy') {
            stageTitle.innerText = "המשחק: ריסוק האבנים";
            stageContent.innerHTML = "גררו את הצינורית לאבן וכוונו במדויק. לחצו על הלייזר כדי לפורר אותה. הירי גורם לעכירות, המתינו לראות טובה.";
            laserBtn.classList.add('visible');
            
            targetZoom = 2.5;
            if (fullPath.length > 0) {
                if(stones.length === 0) initStones();
                
                const target = stones[0] || fullPath[fullPath.length-1];
                targetOffset = {
                    x: (width / 2) - (target.x * 2.5),
                    y: (height / 2) - (target.y * 2.5)
                };
            }
        }
        else if (stage === 'post_op') {
            modal.classList.remove('hidden');
            successScreen.classList.remove('hidden');
            instructionBox.classList.add('hidden');
            backBtn.classList.add('hidden');
        }
    }

    function nextStage() { goToStage(currentStageIndex + 1); }
    function goBack() { goToStage(currentStageIndex - 1); }

    function generateFullPaths(w, h) {
        if (!w || !h) return [];
        const points = [];
        const handleX = w * 0.15 + 10;
        const handleY = h * 0.85 - 30;
        const entryX = w * 0.5;
        const entryY = h * 0.95;

        addBezierCurvePoints(points, handleX, handleY, handleX + 50, handleY - 100, entryX - 50, entryY + 50, entryX, entryY, 25);
        organStartIndex = points.length - 1;

        addLinePoints(points, w * 0.5, h * 0.95, w * 0.5, h * 0.75, 20); 
        addQuadCurvePoints(points, w * 0.5, h * 0.75, w * 0.5, h * 0.65, w * 0.55, h * 0.60, 20); 
        addBezierCurvePoints(points, w * 0.55, h * 0.60, w * 0.65, h * 0.55, w * 0.70, h * 0.40, w * 0.70, h * 0.20, 50); 
        
        return points;
    }

    function addLinePoints(arr, x1, y1, x2, y2, steps) {
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            arr.push({ x: x1 + (x2 - x1) * t, y: y1 + (y2 - y1) * t });
        }
    }
    function addQuadCurvePoints(arr, x1, y1, cx, cy, x2, y2, steps) {
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const invT = 1 - t;
            arr.push({
                x: invT * invT * x1 + 2 * invT * t * cx + t * t * x2,
                y: invT * invT * y1 + 2 * invT * t * cy + t * t * y2
            });
        }
    }
    function addBezierCurvePoints(arr, x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2, steps) {
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const invT = 1 - t;
            const x = (invT ** 3) * x1 + 3 * (invT ** 2) * t * cp1x + 3 * invT * (t ** 2) * cp2x + (t ** 3) * x2;
            const y = (invT ** 3) * y1 + 3 * (invT ** 2) * t * cp1y + 3 * invT * (t ** 2) * cp2y + (t ** 3) * y2;
            arr.push({x, y});
        }
    }

    // --- Drawing ---
    function drawLargeDevice() {
        ctx.save();
        const cy = height / 2 + 60; 
        const cx = width / 2;
        ctx.translate(cx, cy);
        
        ctx.rotate(-Math.PI / 4);
        ctx.fillStyle = '#2d3748';
        ctx.beginPath();
        ctx.roundRect(-40, -100, 80, 200, 20);
        ctx.fill();
        
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(-30, -50); ctx.lineTo(30, -50);
        ctx.moveTo(-30, 0); ctx.lineTo(30, 0);
        ctx.moveTo(-30, 50); ctx.lineTo(30, 50);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -100);
        ctx.bezierCurveTo(0, -250, 200, -250, 200, -100);
        ctx.strokeStyle = '#2D3748';
        ctx.lineWidth = 12;
        ctx.stroke();
        
        ctx.fillStyle = '#A0AEC0';
        ctx.fillRect(194, -100, 12, 20);
        
        ctx.restore();
        
        ctx.fillStyle = "white";
        ctx.font = "bold 16px Rubik";
        ctx.textAlign = "center";
        
        ctx.fillText("ידית אחיזה", cx - 80, cy + 80);
        ctx.fillText("סיב גמיש", cx + 40, cy - 240);
        ctx.fillText("מצלמה ולייזר", cx + 180, cy - 205);
        
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        
        ctx.moveTo(cx - 80, cy + 70); ctx.lineTo(cx - 20, cy + 20);
        ctx.moveTo(cx + 40, cy - 235); ctx.lineTo(cx + 10, cy - 200); 
        ctx.moveTo(cx + 130, cy - 210); ctx.lineTo(cx + 85, cy - 205); 
        
        ctx.stroke();
    }

    function drawOrgans() {
        if (fullPath.length === 0) return;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const endP = fullPath[fullPath.length - 1];
        
        ctx.save();
        ctx.translate(endP.x, endP.y);
        ctx.rotate(-Math.PI / 2); 
        ctx.beginPath();
        ctx.moveTo(0, -50);
        ctx.bezierCurveTo(60, -60, 60, 60, 0, 50);
        ctx.bezierCurveTo(-30, 30, -30, -30, 0, -50);
        ctx.fillStyle = KIDNEY_COLOR;
        ctx.strokeStyle = KIDNEY_STROKE;
        ctx.lineWidth = 8;
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.beginPath();
        ctx.ellipse(width * 0.5, height * 0.70, width * 0.15, height * 0.12, 0, 0, Math.PI * 2);
        ctx.fillStyle = KIDNEY_COLOR;
        ctx.strokeStyle = KIDNEY_STROKE;
        ctx.lineWidth = 8;
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        if (fullPath[organStartIndex]) {
            ctx.beginPath();
            const startP = fullPath[organStartIndex];
            ctx.moveTo(startP.x, startP.y);
            for(let i=organStartIndex + 1; i<fullPath.length; i++) {
                ctx.lineTo(fullPath[i].x, fullPath[i].y);
            }
            ctx.strokeStyle = TRACT_STROKE;
            ctx.lineWidth = 40;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(startP.x, startP.y);
            for(let i=organStartIndex + 1; i<fullPath.length; i++) {
                ctx.lineTo(fullPath[i].x, fullPath[i].y);
            }
            ctx.strokeStyle = TRACT_COLOR;
            ctx.lineWidth = 30;
            ctx.stroke();
        }
    }

    function drawUreteroscopeHandle() {
        const handleX = width * 0.15;
        const handleY = height * 0.85; 
        ctx.save();
        ctx.translate(handleX, handleY);
        ctx.rotate(-0.3); 
        ctx.fillStyle = '#2d3748';
        ctx.beginPath(); ctx.roundRect(-20, -40, 40, 100, 10); ctx.fill();
        ctx.strokeStyle = '#4a5568'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(-15, -20); ctx.lineTo(15, -20); ctx.moveTo(-15, 0); ctx.lineTo(15, 0); ctx.moveTo(-15, 20); ctx.lineTo(15, 20); ctx.stroke();
        ctx.fillStyle = '#4a5568'; ctx.beginPath(); ctx.arc(0, -40, 30, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#718096'; ctx.beginPath(); ctx.arc(0, -55, 10, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }

    function updateLabels() {
        labelsContainer.innerHTML = '';
        const stage = STAGES[currentStageIndex];
        if (stage !== 'demo_tract' && stage !== 'navigate_tract' && stage !== 'demo_handle') return; 
        if (fullPath.length === 0) return;

        const labels = [
            { text: "כליה", x: fullPath[fullPath.length-1].x - 60, y: fullPath[fullPath.length-1].y },
            { text: "שלפוחית", x: width * 0.65, y: height * 0.75 },
        ];

        labels.forEach(l => {
            const div = document.createElement('div');
            div.className = 'anatomy-label';
            div.innerText = l.text;
            div.style.left = l.x + 'px';
            div.style.top = l.y + 'px';
            labelsContainer.appendChild(div);
        });
    }

    class Stone {
        constructor(x, y, radius, level = 0) {
            this.x = x; this.y = y; this.radius = radius; this.level = level; this.health = 100;
            this.vertices = [];
            const sides = 8;
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 * i) / sides;
                const r = this.radius * (0.7 + Math.random() * 0.6);
                this.vertices.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
            }
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            // Apply breathing only if NOT basket/dragging
            if (isLaserActive && (STAGES[currentStageIndex] === 'destroy' || STAGES[currentStageIndex] === 'laser_explainer')) {
                ctx.translate(Math.random()*2 - 1, Math.random()*2 - 1);
            }
            ctx.beginPath();
            ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
            for (let i = 1; i < this.vertices.length; i++) {
                ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = STONE_COLOR;
            ctx.fill();
            ctx.strokeStyle = '#744210';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            if (this.health < 70) {
                 ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(this.vertices[0].x, this.vertices[0].y); ctx.stroke();
            }
            ctx.restore();
        }
        hit() {
            this.health -= 2;
            createParticles(this.x, this.y + breathOffset, STONE_COLOR); 
            visibilityObscurity = Math.min(visibilityObscurity + 0.25, 0.98);
            return (this.health <= 0);
        }
    }

    function initStones() {
        if (fullPath.length === 0) return;
        const loc = fullPath[fullPath.length - 5]; 
        stones = [new Stone(loc.x, loc.y, 20, 0)];
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8;
            this.life = 1.0; this.color = color; this.size = Math.random() * 3 + 1;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        draw() {
            ctx.globalAlpha = this.life; 
            ctx.fillStyle = this.color;
            // Changed from square (fillRect) to circle (arc) for natural look
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }
    function createParticles(x, y, color) {
        // Particles removed per user request
    }

    function initScopeAt(startIndex) {
        if (fullPath.length === 0) return;
        scopeChain = [];
        if (startIndex < 0 || startIndex >= fullPath.length) startIndex = 0;
        const startP = fullPath[startIndex];
        const segments = 200; 
        
        if (startIndex === 0) {
            for(let i=0; i<segments; i++) {
                scopeChain.push({ x: startP.x, y: startP.y });
            }
        } else {
            const spacing = 5;
            for(let i=0; i<segments; i++) {
                scopeChain.push({ 
                    x: startP.x, 
                    y: startP.y + (i * spacing) 
                });
            }
        }
    }

    function initScope() { initScopeAt(0); }

    function updateScope() {
        if (fullPath.length === 0 || scopeChain.length === 0) return;
        const stage = STAGES[currentStageIndex];

        if (stage === 'demo_handle') {
            if (scopeProgressIndex < organStartIndex) {
                scopeProgressIndex += 0.2;
                const idx = Math.floor(scopeProgressIndex);
                if(fullPath[idx]) { scopeChain[0].x = fullPath[idx].x; scopeChain[0].y = fullPath[idx].y; }
            } else { nextStageBtn.classList.remove('hidden'); }
        }
        else if (stage === 'demo_tract') {
            if (scopeProgressIndex < fullPath.length - 10) {
                scopeProgressIndex += 0.2;
                const idx = Math.floor(scopeProgressIndex);
                if(fullPath[idx]) { scopeChain[0].x = fullPath[idx].x; scopeChain[0].y = fullPath[idx].y; }
            } else { nextStageBtn.classList.remove('hidden'); }
        }
        else if (stage === 'laser_explainer') {
            const targetIdx = fullPath.length - 8;
            if (Math.abs(scopeProgressIndex - targetIdx) > 5) scopeProgressIndex = targetIdx;
             const idx = Math.floor(scopeProgressIndex);
            if(fullPath[idx]) { scopeChain[0].x = fullPath[idx].x; scopeChain[0].y = fullPath[idx].y; }

            autoLaserTimer++;
            if (autoLaserTimer % 120 < 60) {
                isLaserActive = true;
                if (stones.length > 0) createParticles(stones[0].x, stones[0].y + breathOffset, STONE_COLOR);
            } else { isLaserActive = false; }
        }
        else if (stage === 'navigate_handle') {
            if (isGrabbingTip) {
                handleDragInputPath(0, organStartIndex + 2);
                const idx = Math.floor(scopeProgressIndex);
                if(fullPath[idx]) { scopeChain[0].x = fullPath[idx].x; scopeChain[0].y = fullPath[idx].y; }
            }
            if (scopeProgressIndex >= organStartIndex) nextStage();
        }
        else if (stage === 'navigate_tract' || stage === 'destroy') {
            if (isGrabbingTip && (stage === 'navigate_tract' || stage === 'destroy')) {
                updateHeadFreeMovement(organStartIndex, fullPath.length - 1);
            }
            
            if (stage === 'navigate_tract') {
                const head = scopeChain[0];
                let bestIdx = -1; 
                let bestDist = Infinity;
                for(let i=fullPath.length-30; i<fullPath.length; i++) {
                    const p = fullPath[i];
                    const d = Math.hypot(head.x - p.x, head.y - p.y);
                    if(d < bestDist) { bestDist = d; bestIdx = i; }
                }
                if (bestDist < 40 && bestIdx >= fullPath.length - 20) {
                    nextStage();
                }
            }
        }
        
        const segLength = 5; 
        for (let i = 1; i < scopeChain.length; i++) {
            const prev = scopeChain[i - 1];
            const curr = scopeChain[i];
            const dx = curr.x - prev.x;
            const dy = curr.y - prev.y;
            const dist = Math.hypot(dx, dy);
            if (dist > segLength) {
                const ratio = (dist - segLength) / dist;
                curr.x -= dx * ratio;
                curr.y -= dy * ratio;
            }
        }
    }

    function handleDragInputPath(minIdx, maxIdx) {
        let closestDist = Infinity;
        let closestIdx = -1;
        let searchWindow = 60; 
        let startSearch = Math.max(minIdx, scopeProgressIndex - searchWindow);
        let endSearch = Math.min(maxIdx, scopeProgressIndex + searchWindow);
        
        if (scopeProgressIndex < minIdx + 5) startSearch = minIdx;

        for(let i = startSearch; i <= endSearch; i++) {
            const p = fullPath[i];
            if(!p) continue;
            const d = Math.hypot(mouse.x - p.x, mouse.y - p.y);
            if (d < closestDist) { closestDist = d; closestIdx = i; }
        }
        
        if (closestDist < 300) {
            if (closestIdx > scopeProgressIndex) scopeProgressIndex += 0.2;
            if (closestIdx < scopeProgressIndex) scopeProgressIndex -= 0.2;
            if (scopeProgressIndex < minIdx) scopeProgressIndex = minIdx;
            if (scopeProgressIndex > maxIdx) scopeProgressIndex = maxIdx;
        }
    }

    function updateHeadFreeMovement(minPathIdx, maxPathIdx) {
        // Removed collision detection flag logic, retained wall clamping
        const head = scopeChain[0];
        
        let dx = mouse.x - head.x;
        let dy = mouse.y - head.y;
        
        const speed = 1.0;
        const distToMouse = Math.hypot(dx, dy);
        
        if (distToMouse > speed) {
            dx = (dx / distToMouse) * speed;
            dy = (dy / distToMouse) * speed;
        }
        
        let nextX = head.x + dx;
        let nextY = head.y + dy;

        let wallRefP = null;
        let wallRefDist = Infinity;
        
        // Find closest point on tract to 'next' position
        // Only scan part of the tract that is the organ (after entry)
        // Optimization: scan local window of last known progress? 
        // For simplicity, scan whole tract segment (organStartIndex to end)
        // But since user can drag anywhere, better to scan entire organ section
        
        // Optimization: We can limit search around current position index
        // But free movement means index isn't perfectly tracked.
        // Let's do a somewhat brute force search on the relevant path segment.
        // For 100 points it's fast enough.
        
        for(let i=minPathIdx; i<=maxPathIdx; i++) {
            const p = fullPath[i];
            const d = Math.hypot(nextX - p.x, nextY - p.y);
            if (d < wallRefDist) { wallRefDist = d; wallRefP = p; }
        }

        if (wallRefDist > TRACT_RADIUS) {
            const vX = nextX - wallRefP.x;
            const vY = nextY - wallRefP.y;
            const len = Math.hypot(vX, vY);
            // Clamp to radius
            nextX = wallRefP.x + (vX / len) * TRACT_RADIUS;
            nextY = wallRefP.y + (vY / len) * TRACT_RADIUS;
        }

        scopeChain[0].x = nextX;
        scopeChain[0].y = nextY;
    }

    function drawScope() {
        if (scopeChain.length === 0) return;

        ctx.beginPath();
        ctx.moveTo(scopeChain[0].x, scopeChain[0].y);
        for (let i = 1; i < scopeChain.length - 1; i++) {
            const xc = (scopeChain[i].x + scopeChain[i + 1].x) / 2;
            const yc = (scopeChain[i].y + scopeChain[i + 1].y) / 2;
            ctx.quadraticCurveTo(scopeChain[i].x, scopeChain[i].y, xc, yc);
        }
        ctx.strokeStyle = '#2D3748';
        ctx.lineWidth = 6;
        ctx.stroke();
        ctx.strokeStyle = '#718096';
        ctx.lineWidth = 2;
        ctx.stroke();

        const tip = scopeChain[0];
        const prev = scopeChain[1];
        const angle = Math.atan2(tip.y - prev.y, tip.x - prev.x);

        ctx.save();
        ctx.translate(tip.x, tip.y);
        ctx.rotate(angle);
        
        ctx.fillStyle = '#A0AEC0'; ctx.fillRect(-5, -6, 10, 12);
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

        // Light cone
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(100, -30); ctx.lineTo(100, 30); ctx.closePath();
        const grad = ctx.createRadialGradient(0,0,10, 0,0,100);
        grad.addColorStop(0, 'rgba(255,255,255,0.4)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fill();

        if (isLaserActive) {
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            
            // --- LASER RAY CASTING START ---
            let laserLen = 200; // Default max length
            
            // Check collisions with stones to shorten laser
            if (stones.length > 0) {
                for(let s of stones) {
                    // Simple logic:
                    // Transform stone center to local tip coordinates
                    // LocalX = (s.x - tip.x) * cos(-angle) - (s.y - tip.y) * sin(-angle)
                    // LocalY = (s.x - tip.x) * sin(-angle) + (s.y - tip.y) * cos(-angle)
                    
                    // We need to account for breathOffset on stones!
                    const stoneVisualY = s.y + breathOffset;
                    
                    const dx = s.x - tip.x;
                    const dy = stoneVisualY - tip.y;
                    
                    // Rotate by -angle
                    const cosA = Math.cos(-angle);
                    const sinA = Math.sin(-angle);
                    
                    const localX = dx * cosA - dy * sinA;
                    const localY = dx * sinA + dy * cosA;
                    
                    // Check if stone is in front (localX > 0) and intersecting beam width
                    // Beam is thin (y=0), so check if |localY| < radius
                    if (localX > 0 && Math.abs(localY) < s.radius) {
                        // Calculate intersection distance
                        // x = localX - sqrt(r^2 - localY^2)
                        const intersectDist = localX - Math.sqrt(s.radius * s.radius - localY * localY);
                        
                        // If intersection is valid and closer than current length
                        if (intersectDist >= 0 && intersectDist < laserLen) {
                            laserLen = intersectDist;
                        }
                    }
                }
            }
            
            ctx.lineTo(laserLen, 0); 
            // --- LASER RAY CASTING END ---
            
            ctx.strokeStyle = '#F56565';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10; ctx.shadowColor = 'red';
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        ctx.restore();

        const stage = STAGES[currentStageIndex];
        if ((stage === 'navigate_handle' || stage === 'navigate_tract' || stage === 'destroy') && !isGrabbingTip) {
            ctx.save();
            ctx.translate(tip.x, tip.y);
            const pulse = (Math.sin(Date.now() / 200) + 1) / 2; 
            ctx.beginPath();
            ctx.arc(0, 0, 20 + pulse * 10, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(99, 179, 237, ${0.8 - pulse * 0.5})`; 
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }
    }

    function loop() {
        const stage = STAGES[currentStageIndex];
        ctx.clearRect(0, 0, width, height);

        if (visibilityObscurity > 0) {
            visibilityObscurity -= 0.005; 
            if (visibilityObscurity < 0) visibilityObscurity = 0;
        }

        cameraZoom += (targetZoom - cameraZoom) * 0.05;
        cameraOffset.x += (targetOffset.x - cameraOffset.x) * 0.05;
        cameraOffset.y += (targetOffset.y - cameraOffset.y) * 0.05;

        if (stage === 'destroy' || stage === 'laser_explainer') {
            breathOffset = Math.sin(Date.now() / 800) * 8; 
        } else {
            breathOffset = 0;
        }

        ctx.save();
        ctx.translate(cameraOffset.x, cameraOffset.y);
        ctx.scale(cameraZoom, cameraZoom);
        
        if (stage === 'device_intro') {
            drawLargeDevice();
        } else {
            if (stage === 'demo_handle' || stage === 'navigate_handle') {
                drawUreteroscopeHandle();
            }

            ctx.save();
            ctx.translate(0, breathOffset);
            drawOrgans();
            stones.forEach(s => s.draw());
            ctx.restore();

            drawScope();
            particles.forEach(p => p.draw());

            updateScope();

            if (stage === 'destroy') {
                if (isLaserActive && scopeChain.length > 0 && stones.length > 0) {
                    for (let i = stones.length - 1; i >= 0; i--) {
                        const s = stones[i];
                        const tip = scopeChain[0];
                        const visualStoneY = s.y + breathOffset;
                        const d = Math.hypot(tip.x - s.x, tip.y - visualStoneY);
                        
                        if (d < 30) { 
                            const destroyed = s.hit(); 
                            if (destroyed) {
                                if (s.level === 0) {
                                    stones.push(new Stone(s.x - 15, s.y - 10, 12, 1));
                                    stones.push(new Stone(s.x + 15, s.y + 10, 12, 1));
                                    stones.push(new Stone(s.x, s.y + 15, 12, 1));
                                }
                                stones.splice(i, 1);
                            }
                        }
                    }
                }

                if (stones.length === 0) {
                    if (!levelCompleteTime) {
                        levelCompleteTime = Date.now();
                    }
                    if (Date.now() - levelCompleteTime > 2000) {
                        nextStage();
                        levelCompleteTime = null;
                    }
                }
            }
        }
        ctx.restore();

        if (visibilityObscurity > 0) {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.fillStyle = `rgba(240, 248, 255, ${visibilityObscurity * 0.9})`; 
            ctx.fillRect(0, 0, width, height);
            ctx.restore();
        }

        requestAnimationFrame(loop);
    }

    function handleResize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        fullPath = generateFullPaths(width, height);
        updateLabels();
        initStones(); 
        if (currentStageIndex === 0) drawOrgans(); 
    }

    function onMove(e) {
        e.preventDefault();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const rect = canvas.getBoundingClientRect();
        
        mouse.x = (clientX - rect.left - cameraOffset.x) / cameraZoom;
        mouse.y = (clientY - rect.top - cameraOffset.y) / cameraZoom;
        
        if (!isGrabbingTip && scopeChain.length > 0) {
            const tip = scopeChain[0];
            if (Math.hypot(mouse.x - tip.x, mouse.y - tip.y) < 100) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'default';
            }
        }
    }

    function onDown(e) { 
        mouse.isDown = true; 
        onMove(e); 
        
        if (scopeChain.length > 0) {
            const tip = scopeChain[0];
            if (Math.hypot(mouse.x - tip.x, mouse.y - tip.y) < 100) {
                isGrabbingTip = true;
                canvas.style.cursor = 'grabbing';
            }
        }
    }

    function onUp(e) { 
        mouse.isDown = false; 
        isLaserActive = false; 
        isGrabbingTip = false;
        canvas.style.cursor = 'default';
    }

    window.addEventListener('resize', handleResize);
    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    canvas.addEventListener('touchstart', onDown, {passive: false});
    canvas.addEventListener('touchmove', onMove, {passive: false});
    window.addEventListener('touchend', onUp);

    laserBtn.addEventListener('mousedown', (e) => {
        if (STAGES[currentStageIndex] === 'destroy') isLaserActive = true;
        e.stopPropagation();
    });
    laserBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (STAGES[currentStageIndex] === 'destroy') isLaserActive = true;
        e.stopPropagation();
    });
    laserBtn.addEventListener('mouseup', () => isLaserActive = false);
    laserBtn.addEventListener('touchend', () => isLaserActive = false);

    function resetGame() { goToStage(0); }
    handleResize();

</script>
</body>
</html>
