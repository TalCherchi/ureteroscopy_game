<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>סימולטור ריסוק אבנים</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
            font-family: 'Rubik', sans-serif;
            color: white;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: #0f131a;
            border-radius: 8px;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* Header Styles */
        .header {
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 20px;
            align-self: center;
            backdrop-filter: blur(4px);
            max-width: 90%;
            border: 1px solid #4a5568;
            transition: all 0.5s ease;
            position: relative;
        }

        .header.top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            right: auto;
            align-self: flex-start;
            text-align: right;
            max-width: 300px;
            transform: none;
            margin: 0;
        }

        h1 { margin: 0; font-size: 1.3rem; color: #63b3ed; margin-bottom: 8px; }
        p { margin: 5px 0 0; font-size: 1rem; color: #e2e8f0; line-height: 1.5; }
        .subtext { font-size: 0.85rem; color: #a0aec0; margin-top: 10px; display: block; }
        
        ul { text-align: right; padding-right: 20px; margin: 10px 0; font-size: 0.95rem; color: #cbd5e0; }
        li { margin-bottom: 5px; }

        /* Buttons */
        .btn-action {
            pointer-events: auto;
            background: #3182ce;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 15px;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .btn-action:active { transform: scale(0.95); }
        .btn-action.secondary {
            background: transparent;
            border: 2px solid #4a5568;
            padding: 8px 20px;
            font-size: 0.9rem;
            color: #cbd5e0;
            margin-top: 10px;
            background-color: rgba(0,0,0,0.3); /* better visibility */
        }

        /* Laser Button */
        #laser-btn {
            pointer-events: auto;
            align-self: center;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, #fc8181 0%, #c53030 100%);
            border: 4px solid #fff;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 0 15px #c53030;
            transition: transform 0.1s, opacity 0.3s;
            opacity: 0; 
            transform: scale(0);
            margin-bottom: 20px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #laser-btn.visible {
            opacity: 1;
            transform: scale(1);
        }

        #laser-btn.active {
            box-shadow: 0 0 25px #f56565, 0 0 50px #f56565 inset;
            animation: pulse 1s infinite;
        }

        /* Modal / Instructions */
        #modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        .modal-content {
            background: white;
            color: #2d3748;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        .modal-content h2 { margin-top: 0; color: #2b6cb0; font-size: 1.5rem; }
        .modal-content p { color: #4a5568; margin-bottom: 15px; }
        
        .info-list { text-align: right; background: #f7fafc; padding: 15px; border-radius: 8px; margin: 10px 0; }
        .info-list h3 { font-size: 1rem; color: #2d3748; margin: 0 0 5px 0; }
        .info-list ul { padding-right: 20px; margin: 0; color: #4a5568; }

        .hidden { display: none !important; }

        /* Bottom navigation bar - Moved Back button to right */
        .bottom-nav {
            position: absolute;
            bottom: 20px;
            right: 20px; /* Aligned to right */
            left: auto;
            width: auto;
            display: flex;
            pointer-events: none;
        }
        .bottom-nav button {
            pointer-events: auto;
        }

        /* Labels for Anatomy */
        .anatomy-label {
            position: absolute;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="labels-container"></div>

    <div class="ui-layer">
        <!-- Main Info Box -->
        <div class="header hidden" id="game-instruction-box">
            <h1 id="stage-title">כותרת</h1>
            <div id="stage-content">תוכן</div>
            <button id="next-stage-btn" class="btn-action hidden" onclick="nextStage()">המשך</button>
        </div>

        <!-- Laser Button -->
        <div id="laser-btn">לייזר</div>

        <!-- Back Button -->
        <div class="bottom-nav">
            <button id="back-btn" class="btn-action secondary hidden" onclick="goBack()">חזור</button>
        </div>
    </div>

    <!-- Modals -->
    <div id="modal">
        <div class="modal-content" id="start-screen">
            <h2>ברוכים הבאים לסימולציה</h2>
            <p>בסימולציה הזו נלמד בצורה רגועה וברורה מה קורה במהלך ניתוח אורטרוסקופיה – הליך קצר שנועד לאתר או להסיר אבנים מדרכי השתן.</p>
            <span class="subtext">הסימולציה אורכת כ-5 דקות • בכל שלב תוכלו לעצור ולחזור</span>
            <button class="btn-action" onclick="startGameFlow()">בואו נתחיל</button>
        </div>
        
        <div class="modal-content hidden" id="success-screen">
            <h2 style="color: #38a169;">הניתוח עבר בהצלחה!</h2>
            
            <div class="info-list">
                <h3>אחרי הניתוח – מה מרגישים?</h3>
                <ul>
                    <li>מיד לאחר ההליך תישארו למעקב קצר. לרוב חוזרים הביתה באותו יום.</li>
                    <li>ביום-יומיים הראשונים ייתכן צריבה קלה או צורך דחוף להשתין. זה טבעי וחולף.</li>
                    <li>חשוב לפעול לפי הוראות הרופא וליטול תרופות במידת הצורך.</li>
                </ul>
            </div>

            <div class="info-list" style="background: #e6fffa;">
                <h3>תופעות נפוצות (טבעיות):</h3>
                <ul>
                    <li>צריבה קלה בשתן</li>
                    <li>צורך תכוף להשתין</li>
                    <li>דם קל בשתן (ביומיים הראשונים)</li>
                    <li>תחושת אי נוחות קלה</li>
                </ul>
                <p style="margin-top:5px; font-weight:bold; color: #2c7a7b;">✓ כל התופעות הללו חולפות תוך מספר ימים</p>
            </div>
            <button class="btn-action" onclick="resetGame()">התחל מחדש</button>
        </div>
    </div>
</div>

<script>
    // --- Configuration & State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const laserBtn = document.getElementById('laser-btn');
    const modal = document.getElementById('modal');
    const startScreen = document.getElementById('start-screen');
    const successScreen = document.getElementById('success-screen');
    const labelsContainer = document.getElementById('labels-container');
    const instructionBox = document.getElementById('game-instruction-box');
    const stageTitle = document.getElementById('stage-title');
    const stageContent = document.getElementById('stage-content');
    const nextStageBtn = document.getElementById('next-stage-btn');
    const backBtn = document.getElementById('back-btn');

    const STAGES = [
        'intro', 
        'demo_handle', 'demo_tract', 
        'laser_explainer', 
        'navigate_handle', 'navigate_tract', 
        'destroy', 
        'post_op'
    ];
    let currentStageIndex = 0;
    
    let isLaserActive = false;
    let autoLaserTimer = 0;
    
    let width, height;
    
    // Entities
    let fullPath = []; 
    let organStartIndex = 0;
    let scopeChain = []; 
    let stones = []; 
    let particles = [];
    
    // Camera
    let cameraZoom = 1;
    let cameraOffset = { x: 0, y: 0 };
    let targetZoom = 1;
    let targetOffset = { x: 0, y: 0 };

    // Interaction
    const mouse = { x: 0, y: 0, isDown: false };
    let scopeProgressIndex = 0; 
    
    // Constants
    const KIDNEY_COLOR = '#FEB2B2';
    const KIDNEY_STROKE = '#E53E3E';
    const TRACT_COLOR = '#FED7D7';
    const TRACT_STROKE = '#F56565';
    const STONE_COLOR = '#D69E2E';
    const TRACT_RADIUS = 14; // Approximate radius for wall collision (half of lineWidth 30)

    let levelCompleteTime = null; // New variable to track win animation time

    function startGameFlow() {
        modal.classList.add('hidden');
        startScreen.classList.add('hidden');
        successScreen.classList.add('hidden');
        
        handleResize(); // Generates path
        // Force stone init after path is ready
        initStones();
        
        goToStage(1); 
        requestAnimationFrame(loop);
    }

    function goToStage(index) {
        if (index < 0) index = 0;
        if (index >= STAGES.length) index = STAGES.length - 1;
        
        currentStageIndex = index;
        const stage = STAGES[index];

        // UI Reset
        instructionBox.classList.remove('hidden');
        instructionBox.classList.remove('top-left'); 
        nextStageBtn.classList.add('hidden');
        laserBtn.classList.remove('visible');
        backBtn.classList.remove('hidden');
        
        // View Reset
        targetZoom = 1;
        targetOffset = {x: 0, y:0};
        autoLaserTimer = 0;
        isLaserActive = false;
        levelCompleteTime = null; // Reset win timer

        // Stage Logic
        if (stage === 'intro') {
            modal.classList.remove('hidden');
            startScreen.classList.remove('hidden');
            backBtn.classList.add('hidden');
            instructionBox.classList.add('hidden');
        }
        else if (stage === 'demo_handle') {
            instructionBox.classList.add('top-left');
            stageTitle.innerText = "שלב 1: החדרת המכשיר";
            stageContent.innerHTML = `
                <p>הבדיקה מתחילה בהחדרת צינורית דקה וגמישה דרך פתח השופכה.</p>
                <div style="margin-top:10px; font-weight:bold; color: #90cdf4;">✓ ללא חתכים בגוף</div>
            `;
            scopeProgressIndex = 0;
            initScopeAt(0);
            nextStageBtn.classList.add('hidden');
        }
        else if (stage === 'demo_tract') {
            instructionBox.classList.add('top-left');
            stageTitle.innerText = "שלב 2: תנועה בדרכי השתן";
            stageContent.innerHTML = `
                <p>הצינורית מתקדמת בעדינות במעלה השופכן עד להגעה לכליה.</p>
            `;
            targetZoom = 1.3;
            targetOffset = {
                x: (width/2) * (1 - targetZoom), 
                y: (height * 0.4) * (1 - targetZoom) 
            };
            scopeProgressIndex = organStartIndex;
            initScopeAt(organStartIndex);
            nextStageBtn.classList.add('hidden'); 
        }
        else if (stage === 'laser_explainer') {
            stageTitle.innerText = "ריסוק האבן";
            stageContent.innerHTML = `
                <p>כאשר הרופא מזהה את האבן הוא משתמש בקרן לייזר מדויקת כדי לפרק אותה.</p>
            `;
            targetZoom = 2.0;
            if (fullPath.length > 0) {
                const endP = fullPath[fullPath.length-1];
                targetOffset = {
                    x: (width / 2) - (endP.x * 2.0),
                    y: (height / 2) - (endP.y * 2.0)
                };
            }
            nextStageBtn.classList.remove('hidden');
        }
        else if (stage === 'navigate_handle') {
            instructionBox.classList.add('top-left');
            stageTitle.innerText = "תורכם: החדרת הצינורית";
            stageContent.innerHTML = "גררו את הצינורית <b>מהידית</b> אל תוך פתח השופכה.";
            scopeProgressIndex = 0;
            initScopeAt(0);
        }
        else if (stage === 'navigate_tract') {
            instructionBox.classList.add('top-left');
            stageTitle.innerText = "תורכם: ניווט לכליה";
            stageContent.innerHTML = "המשיכו לגרור את הצינורית בחופשיות. שימו לב שהיא מוגבלת על ידי הדפנות.";
            
            targetZoom = 1.3;
            targetOffset = {
                x: (width/2) * (1 - targetZoom), 
                y: (height * 0.4) * (1 - targetZoom) 
            };
            scopeProgressIndex = organStartIndex;
            initScopeAt(organStartIndex);
        }
        else if (stage === 'destroy') {
            stageTitle.innerText = "המשחק: ריסוק האבנים";
            stageContent.innerHTML = "לחצו על כפתור הלייזר כדי לפורר את האבנים הגדולות.";
            laserBtn.classList.add('visible');
            
            targetZoom = 2.5;
            if (fullPath.length > 0) {
                // Ensure stone exists for targeting
                if(stones.length === 0) initStones();
                
                const target = stones[0] || fullPath[fullPath.length-1];
                targetOffset = {
                    x: (width / 2) - (target.x * 2.5),
                    y: (height / 2) - (target.y * 2.5)
                };
            }
        }
        else if (stage === 'post_op') {
            modal.classList.remove('hidden');
            successScreen.classList.remove('hidden');
            instructionBox.classList.add('hidden');
            backBtn.classList.add('hidden');
        }
    }

    function nextStage() { goToStage(currentStageIndex + 1); }
    function goBack() { goToStage(currentStageIndex - 1); }

    function generateFullPaths(w, h) {
        if (!w || !h) return [];
        const points = [];
        const handleX = w * 0.15 + 10;
        const handleY = h * 0.85 - 30;
        const entryX = w * 0.5;
        const entryY = h * 0.95;

        addBezierCurvePoints(points, handleX, handleY, handleX + 50, handleY - 100, entryX - 50, entryY + 50, entryX, entryY, 25);
        organStartIndex = points.length - 1;

        addLinePoints(points, w * 0.5, h * 0.95, w * 0.5, h * 0.75, 20); 
        addQuadCurvePoints(points, w * 0.5, h * 0.75, w * 0.5, h * 0.65, w * 0.55, h * 0.60, 20); 
        addBezierCurvePoints(points, w * 0.55, h * 0.60, w * 0.65, h * 0.55, w * 0.70, h * 0.40, w * 0.70, h * 0.20, 50); 
        
        return points;
    }

    function addLinePoints(arr, x1, y1, x2, y2, steps) {
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            arr.push({ x: x1 + (x2 - x1) * t, y: y1 + (y2 - y1) * t });
        }
    }
    function addQuadCurvePoints(arr, x1, y1, cx, cy, x2, y2, steps) {
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const invT = 1 - t;
            arr.push({
                x: invT * invT * x1 + 2 * invT * t * cx + t * t * x2,
                y: invT * invT * y1 + 2 * invT * t * cy + t * t * y2
            });
        }
    }
    function addBezierCurvePoints(arr, x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2, steps) {
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const invT = 1 - t;
            const x = (invT ** 3) * x1 + 3 * (invT ** 2) * t * cp1x + 3 * invT * (t ** 2) * cp2x + (t ** 3) * x2;
            const y = (invT ** 3) * y1 + 3 * (invT ** 2) * t * cp1y + 3 * invT * (t ** 2) * cp2y + (t ** 3) * y2;
            arr.push({x, y});
        }
    }

    // --- Drawing ---
    function drawOrgans() {
        if (fullPath.length === 0) return;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const endP = fullPath[fullPath.length - 1];
        
        ctx.save();
        ctx.translate(endP.x, endP.y);
        ctx.rotate(-Math.PI / 2); 
        ctx.beginPath();
        ctx.moveTo(0, -50);
        ctx.bezierCurveTo(60, -60, 60, 60, 0, 50);
        ctx.bezierCurveTo(-30, 30, -30, -30, 0, -50);
        ctx.fillStyle = KIDNEY_COLOR;
        ctx.strokeStyle = KIDNEY_STROKE;
        ctx.lineWidth = 8;
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.beginPath();
        ctx.ellipse(width * 0.5, height * 0.70, width * 0.15, height * 0.12, 0, 0, Math.PI * 2);
        ctx.fillStyle = KIDNEY_COLOR;
        ctx.strokeStyle = KIDNEY_STROKE;
        ctx.lineWidth = 8;
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        if (fullPath[organStartIndex]) {
            ctx.beginPath();
            const startP = fullPath[organStartIndex];
            ctx.moveTo(startP.x, startP.y);
            for(let i=organStartIndex + 1; i<fullPath.length; i++) {
                ctx.lineTo(fullPath[i].x, fullPath[i].y);
            }
            ctx.strokeStyle = TRACT_STROKE;
            ctx.lineWidth = 40;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(startP.x, startP.y);
            for(let i=organStartIndex + 1; i<fullPath.length; i++) {
                ctx.lineTo(fullPath[i].x, fullPath[i].y);
            }
            ctx.strokeStyle = TRACT_COLOR;
            ctx.lineWidth = 30;
            ctx.stroke();
        }
    }

    function drawUreteroscopeHandle() {
        const handleX = width * 0.15;
        const handleY = height * 0.85; 
        ctx.save();
        ctx.translate(handleX, handleY);
        ctx.rotate(-0.3); 
        ctx.fillStyle = '#2d3748';
        ctx.beginPath(); ctx.roundRect(-20, -40, 40, 100, 10); ctx.fill();
        ctx.strokeStyle = '#4a5568'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(-15, -20); ctx.lineTo(15, -20); ctx.moveTo(-15, 0); ctx.lineTo(15, 0); ctx.moveTo(-15, 20); ctx.lineTo(15, 20); ctx.stroke();
        ctx.fillStyle = '#4a5568'; ctx.beginPath(); ctx.arc(0, -40, 30, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#718096'; ctx.beginPath(); ctx.arc(0, -55, 10, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }

    function updateLabels() {
        labelsContainer.innerHTML = '';
        const stage = STAGES[currentStageIndex];
        if (stage !== 'demo_tract' && stage !== 'navigate_tract' && stage !== 'demo_handle') return; 
        if (fullPath.length === 0) return;

        const labels = [
            { text: "כליה", x: fullPath[fullPath.length-1].x - 60, y: fullPath[fullPath.length-1].y },
            { text: "שלפוחית", x: width * 0.65, y: height * 0.75 },
        ];

        labels.forEach(l => {
            const div = document.createElement('div');
            div.className = 'anatomy-label';
            div.innerText = l.text;
            div.style.left = l.x + 'px';
            div.style.top = l.y + 'px';
            labelsContainer.appendChild(div);
        });
    }

    class Stone {
        constructor(x, y, radius, level = 0) {
            this.x = x; this.y = y; this.radius = radius; this.level = level; this.health = 100;
            this.vertices = [];
            const sides = 8;
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 * i) / sides;
                const r = this.radius * (0.7 + Math.random() * 0.6);
                this.vertices.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
            }
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            if (isLaserActive && (STAGES[currentStageIndex] === 'destroy' || STAGES[currentStageIndex] === 'laser_explainer')) {
                ctx.translate(Math.random()*2 - 1, Math.random()*2 - 1);
            }
            ctx.beginPath();
            ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
            for (let i = 1; i < this.vertices.length; i++) {
                ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = STONE_COLOR;
            ctx.fill();
            ctx.strokeStyle = '#744210';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            if (this.health < 70) {
                 ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(this.vertices[0].x, this.vertices[0].y); ctx.stroke();
            }
            ctx.restore();
        }
        hit() {
            this.health -= 2;
            createParticles(this.x, this.y, STONE_COLOR);
            return (this.health <= 0);
        }
    }

    // Force initialization of stones based on current fullPath
    function initStones() {
        if (fullPath.length === 0) return;
        const loc = fullPath[fullPath.length - 5]; 
        stones = [new Stone(loc.x, loc.y, 20, 0)];
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8;
            this.life = 1.0; this.color = color; this.size = Math.random() * 3 + 1;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        draw() {
            ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1.0;
        }
    }
    function createParticles(x, y, color) {
        for(let i=0; i<3; i++) particles.push(new Particle(x, y, color));
    }

    function initScopeAt(startIndex) {
        if (fullPath.length === 0) return;
        scopeChain = [];
        if (startIndex < 0 || startIndex >= fullPath.length) startIndex = 0;
        const startP = fullPath[startIndex];
        // Ensure enough length to look like a continuous cable
        const segments = 200; 
        for(let i=0; i<segments; i++) {
            scopeChain.push({ x: startP.x, y: startP.y });
        }
    }

    function initScope() { initScopeAt(0); }

    function updateScope() {
        if (fullPath.length === 0 || scopeChain.length === 0) return;
        const stage = STAGES[currentStageIndex];

        // --- Demo Stages (Auto Movement) ---
        if (stage === 'demo_handle') {
            if (scopeProgressIndex < organStartIndex) {
                scopeProgressIndex += 0.2;
                // Update Head using Path Index
                const idx = Math.floor(scopeProgressIndex);
                if(fullPath[idx]) {
                    scopeChain[0].x = fullPath[idx].x;
                    scopeChain[0].y = fullPath[idx].y;
                }
            } else {
                nextStageBtn.classList.remove('hidden');
            }
        }
        else if (stage === 'demo_tract') {
            if (scopeProgressIndex < fullPath.length - 10) {
                scopeProgressIndex += 0.2;
                const idx = Math.floor(scopeProgressIndex);
                if(fullPath[idx]) {
                    scopeChain[0].x = fullPath[idx].x;
                    scopeChain[0].y = fullPath[idx].y;
                }
            } else {
                nextStageBtn.classList.remove('hidden');
            }
        }
        else if (stage === 'laser_explainer') {
            // Auto laser demo
            const targetIdx = fullPath.length - 8;
            if (Math.abs(scopeProgressIndex - targetIdx) > 5) {
                scopeProgressIndex = targetIdx;
            }
             const idx = Math.floor(scopeProgressIndex);
            if(fullPath[idx]) {
                scopeChain[0].x = fullPath[idx].x;
                scopeChain[0].y = fullPath[idx].y;
            }

            autoLaserTimer++;
            if (autoLaserTimer % 120 < 60) {
                isLaserActive = true;
                if (stones.length > 0) createParticles(stones[0].x, stones[0].y, STONE_COLOR);
            } else { isLaserActive = false; }
        }
        // --- Navigation Stages (Mouse Control) ---
        else if (stage === 'navigate_handle') {
            // Constrained to path (User is learning)
            if (mouse.isDown) {
                handleDragInputPath(0, organStartIndex + 2);
                const idx = Math.floor(scopeProgressIndex);
                if(fullPath[idx]) {
                    scopeChain[0].x = fullPath[idx].x;
                    scopeChain[0].y = fullPath[idx].y;
                }
            }
            if (scopeProgressIndex >= organStartIndex) nextStage();
        }
        else if (stage === 'navigate_tract' || stage === 'destroy') {
            // **Free Movement with Wall Collision**
            if (mouse.isDown && stage === 'navigate_tract') {
                updateHeadFreeMovement(organStartIndex, fullPath.length - 1);
            }
            
            // Check win condition for navigation
            if (stage === 'navigate_tract') {
                // Find closest path index to current head position
                const head = scopeChain[0];
                let bestIdx = -1; 
                let bestDist = Infinity;
                // Only scan forward
                for(let i=fullPath.length-20; i<fullPath.length; i++) {
                    const p = fullPath[i];
                    const d = Math.hypot(head.x - p.x, head.y - p.y);
                    if(d < bestDist) { bestDist = d; bestIdx = i; }
                }
                // If close to end
                if (bestDist < 40 && bestIdx > fullPath.length - 15) {
                    nextStage();
                }
            }
        }
        
        // --- Kinematics (Tail follows Head) ---
        const segLength = 5; // Tighter segments for smoother look
        for (let i = 1; i < scopeChain.length; i++) {
            const prev = scopeChain[i - 1];
            const curr = scopeChain[i];
            const dx = curr.x - prev.x;
            const dy = curr.y - prev.y;
            const dist = Math.hypot(dx, dy);
            if (dist > segLength) {
                const ratio = (dist - segLength) / dist;
                curr.x -= dx * ratio;
                curr.y -= dy * ratio;
            }
        }
    }

    // Helper: Classic path-constrained drag (for handle stage)
    function handleDragInputPath(minIdx, maxIdx) {
        let closestDist = Infinity;
        let closestIdx = -1;
        let searchWindow = 60; 
        let startSearch = Math.max(minIdx, scopeProgressIndex - searchWindow);
        let endSearch = Math.min(maxIdx, scopeProgressIndex + searchWindow);
        
        if (scopeProgressIndex < minIdx + 5) startSearch = minIdx;

        for(let i = startSearch; i <= endSearch; i++) {
            const p = fullPath[i];
            if(!p) continue;
            const d = Math.hypot(mouse.x - p.x, mouse.y - p.y);
            if (d < closestDist) { closestDist = d; closestIdx = i; }
        }
        
        if (closestDist < 300) {
            // SLOWED DOWN: Reduced speed from 1.0 to 0.4 for smoother control
            if (closestIdx > scopeProgressIndex) scopeProgressIndex += 0.4;
            if (closestIdx < scopeProgressIndex) scopeProgressIndex -= 0.4;
            if (scopeProgressIndex < minIdx) scopeProgressIndex = minIdx;
            if (scopeProgressIndex > maxIdx) scopeProgressIndex = maxIdx;
        }
    }

    // Helper: Free movement with wall constraints
    function updateHeadFreeMovement(minPathIdx, maxPathIdx) {
        const head = scopeChain[0];
        
        // 1. Find closest point on centerline to MOUSE
        let closestP = null;
        let minD = Infinity;
        
        // Step A: Where is the head currently along the path?
        let currentPathIdx = -1;
        let tempMin = Infinity;
        for(let i=minPathIdx; i<=maxPathIdx; i++) {
            const p = fullPath[i];
            const d = Math.hypot(head.x - p.x, head.y - p.y);
            if(d < tempMin) { tempMin = d; currentPathIdx = i; }
        }

        // Step B: Determine target based on mouse
        // We allow the head to move towards mouse, but clamped to walls.
        // Vector: Head -> Mouse
        let dx = mouse.x - head.x;
        let dy = mouse.y - head.y;
        
        // Limit speed to prevent tunneling through walls
        // SLOWED DOWN: Reduced max speed from 4.0 to 2.0
        const speed = 2.0;
        const distToMouse = Math.hypot(dx, dy);
        
        if (distToMouse > speed) {
            dx = (dx / distToMouse) * speed;
            dy = (dy / distToMouse) * speed;
        }
        
        let nextX = head.x + dx;
        let nextY = head.y + dy;

        // Step C: Wall Collision
        // Find closest point on path to *next* position
        let wallRefP = null;
        let wallRefDist = Infinity;
        let searchRange = 50; // Search local area of path
        let startS = Math.max(minPathIdx, currentPathIdx - searchRange);
        let endS = Math.min(maxPathIdx, currentPathIdx + searchRange);

        for(let i=startS; i<=endS; i++) {
            const p = fullPath[i];
            const d = Math.hypot(nextX - p.x, nextY - p.y);
            if (d < wallRefDist) { wallRefDist = d; wallRefP = p; }
        }

        // Apply Wall Constraint
        // If distance to centerline > radius, project back to radius
        if (wallRefDist > TRACT_RADIUS) {
            const vX = nextX - wallRefP.x;
            const vY = nextY - wallRefP.y;
            const len = Math.hypot(vX, vY);
            // Clamp
            nextX = wallRefP.x + (vX / len) * TRACT_RADIUS;
            nextY = wallRefP.y + (vY / len) * TRACT_RADIUS;
        }

        // Apply movement
        scopeChain[0].x = nextX;
        scopeChain[0].y = nextY;
    }

    function drawScope() {
        if (scopeChain.length === 0) return;

        ctx.beginPath();
        ctx.moveTo(scopeChain[0].x, scopeChain[0].y);
        for (let i = 1; i < scopeChain.length - 1; i++) {
            const xc = (scopeChain[i].x + scopeChain[i + 1].x) / 2;
            const yc = (scopeChain[i].y + scopeChain[i + 1].y) / 2;
            ctx.quadraticCurveTo(scopeChain[i].x, scopeChain[i].y, xc, yc);
        }
        ctx.strokeStyle = '#2D3748';
        ctx.lineWidth = 6;
        ctx.stroke();
        ctx.strokeStyle = '#718096';
        ctx.lineWidth = 2;
        ctx.stroke();

        const tip = scopeChain[0];
        const prev = scopeChain[1];
        const angle = Math.atan2(tip.y - prev.y, tip.x - prev.x);

        ctx.save();
        ctx.translate(tip.x, tip.y);
        ctx.rotate(angle);
        
        ctx.fillStyle = '#A0AEC0'; ctx.fillRect(-5, -6, 10, 12);
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(100, -30); ctx.lineTo(100, 30); ctx.closePath();
        const grad = ctx.createRadialGradient(0,0,10, 0,0,100);
        grad.addColorStop(0, 'rgba(255,255,255,0.4)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fill();

        if (isLaserActive) {
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(200, 0); 
            ctx.strokeStyle = '#F56565';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10; ctx.shadowColor = 'red';
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        ctx.restore();
    }

    function loop() {
        const stage = STAGES[currentStageIndex];
        ctx.clearRect(0, 0, width, height);

        cameraZoom += (targetZoom - cameraZoom) * 0.05;
        cameraOffset.x += (targetOffset.x - cameraOffset.x) * 0.05;
        cameraOffset.y += (targetOffset.y - cameraOffset.y) * 0.05;

        ctx.save();
        ctx.translate(cameraOffset.x, cameraOffset.y);
        ctx.scale(cameraZoom, cameraZoom);
        
        if (stage === 'demo_handle' || stage === 'navigate_handle') {
            drawUreteroscopeHandle();
        }

        drawOrgans();
        stones.forEach(s => s.draw());
        drawScope();
        particles.forEach(p => p.draw());

        updateScope();

        // Updated Logic for Destroy Stage
        if (stage === 'destroy') {
            // Destruction Logic
            if (isLaserActive && scopeChain.length > 0 && stones.length > 0) {
                for (let i = stones.length - 1; i >= 0; i--) {
                    const s = stones[i];
                    const tip = scopeChain[0];
                    const d = Math.hypot(tip.x - s.x, tip.y - s.y);
                    if (d < 80) { 
                        const destroyed = s.hit();
                        if (destroyed) {
                            if (s.level === 0) {
                                stones.push(new Stone(s.x - 10, s.y - 10, 12, 1));
                                stones.push(new Stone(s.x + 10, s.y + 10, 12, 1));
                            }
                            stones.splice(i, 1);
                        }
                    }
                }
            }

            // Win Condition with Animation Delay
            if (stones.length === 0) {
                if (!levelCompleteTime) {
                    levelCompleteTime = Date.now();
                }
                // Wait 2 seconds (2000ms) for particles to fade before next stage
                if (Date.now() - levelCompleteTime > 2000) {
                    nextStage();
                    levelCompleteTime = null;
                }
            }
        }
        ctx.restore();

        requestAnimationFrame(loop);
    }

    function handleResize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        fullPath = generateFullPaths(width, height);
        updateLabels();
        initStones(); // Re-init stones on resize to keep correct pos
        if (currentStageIndex === 0) drawOrgans(); 
    }

    function onMove(e) {
        e.preventDefault();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const rect = canvas.getBoundingClientRect();
        mouse.x = (clientX - rect.left - cameraOffset.x) / cameraZoom;
        mouse.y = (clientY - rect.top - cameraOffset.y) / cameraZoom;
    }

    function onDown(e) { mouse.isDown = true; onMove(e); }
    function onUp(e) { mouse.isDown = false; isLaserActive = false; }

    window.addEventListener('resize', handleResize);
    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    canvas.addEventListener('touchstart', onDown, {passive: false});
    canvas.addEventListener('touchmove', onMove, {passive: false});
    window.addEventListener('touchend', onUp);

    laserBtn.addEventListener('mousedown', (e) => {
        if (STAGES[currentStageIndex] === 'destroy') isLaserActive = true;
        e.stopPropagation();
    });
    laserBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (STAGES[currentStageIndex] === 'destroy') isLaserActive = true;
        e.stopPropagation();
    });
    laserBtn.addEventListener('mouseup', () => isLaserActive = false);
    laserBtn.addEventListener('touchend', () => isLaserActive = false);

    function resetGame() { goToStage(0); }
    handleResize();

</script>
</body>
</html>
